# Java 17 Interview Questions - Complete Guide

## üî• JAVA FUNDAMENTALS

**Q1: What is Java and what are its core principles?**
Java is an object-oriented, portable language thanks to the JVM, and strongly typed. Its principles: WORA (Write Once Run Anywhere), automatic memory management via the garbage collector, and robustness through exception handling.

**Q2: Explain the difference between JDK, JRE, and JVM**
- JVM: virtual machine that executes bytecode
- JRE: runtime environment (JVM + libraries)
- JDK: development kit (JRE + compiler + development tools)

**Q3: What is bytecode?**
It is the intermediate code generated by the Java compiler (.class files), platform-independent, which the JVM interprets and compiles into native machine code.

**Q4: How does the Garbage Collector work?**
It automatically frees the memory of unreferenced objects. Several algorithms exist (Serial, Parallel, G1GC, ZGC). It traverses the object graph from the roots, marks reachable objects, then removes the unmarked ones.

**Q5: What are the primitive data types in Java?**
byte (8 bits), short (16), int (32), long (64), float (32), double (64), char (16), boolean (true/false).

---

## üéØ OBJECT-ORIENTED PROGRAMMING

**Q6: Explain the 4 pillars of OOP**
- Encapsulation: hiding implementation details
- Inheritance: code reuse via extends
- Polymorphism: one interface, multiple implementations
- Abstraction: defining contracts via interfaces/abstract classes

**Q7: Difference between an abstract class and an interface?**
Abstract class: can have concrete methods, constructors, instance fields, single inheritance. Interface: abstract methods by default (but can have default/static since Java 8), no constructors, multiple implementation allowed.

**Q8: What is polymorphism? Give examples.**
The ability of an object to take multiple forms. Overloading (compile-time): same name, different parameters. Overriding (runtime): redefining an inherited method.

**Q9: Explain access modifiers**
- private: accessible only within the class
- default (package-private): accessible within the package
- protected: package + subclasses
- public: accessible everywhere

**Q10: Difference between this and super?**
this: references the current instance. super: references the parent class, used to call parent constructor or method.

---

## üì¶ COLLECTIONS

**Q11: What is the Collections hierarchy?**
Collection (root interface) ‚Üí List, Set, Queue. Map is separate. List: ArrayList, LinkedList, Vector. Set: HashSet, TreeSet, LinkedHashSet. Map: HashMap, TreeMap, LinkedHashMap, Hashtable.

**Q12: Difference between ArrayList and LinkedList?**
ArrayList: dynamic array, fast access O(1), slow insertion/deletion O(n). LinkedList: doubly linked list, access O(n), fast insertion/deletion O(1) if you have the reference.

**Q13: Difference between HashSet and TreeSet?**
HashSet: backed by HashMap, unordered, O(1) for add/remove/contains. TreeSet: backed by TreeMap, sorted (natural order or Comparator), O(log n).

**Q14: Difference between HashMap and Hashtable?**
HashMap: not synchronized, accepts null (one key, multiple values), faster. Hashtable: synchronized, rejects null, legacy.

**Q15: How does HashMap work internally?**
Array of buckets (array of Entry). Hash code determines the bucket. Collisions handled by a linked list (or tree if >8 elements since Java 8). Resizing occurs when load factor is exceeded (default 0.75).

**Q16: What is the load factor?**
The fill threshold (capacity √ó load factor) that triggers rehashing. Default is 0.75, a compromise between space and time.

**Q17: Difference between Comparable and Comparator?**
Comparable: natural ordering, interface with compareTo(), single implementation. Comparator: custom ordering, interface with compare(), multiple implementations possible.

**Q18: What are fail-fast and fail-safe?**
Fail-fast: throws ConcurrentModificationException if modified during iteration (ArrayList, HashMap). Fail-safe: copies the collection, no exception (CopyOnWriteArrayList, ConcurrentHashMap).

**Q19: Difference between Iterator and ListIterator?**
Iterator: unidirectional traversal, remove(). ListIterator: bidirectional, add(), set(), index access, only for List.

**Q20: What is ConcurrentHashMap?**
A thread-safe Map without synchronizing the entire map. Uses segment locking (Java 7) then CAS and fine-grained synchronization (Java 8+). Better performance than Hashtable.

---

## üßµ MULTITHREADING

**Q21: How do you create a thread in Java?**
Two ways: extends Thread and override run(), or implements Runnable and pass to Thread. Since Java 8, also with lambda: new Thread(() -> {...}).start()

**Q22: Difference between Thread and Runnable?**
Runnable is a functional interface (separation of task/thread), allows inheriting from another class. Thread is a class, single inheritance only.

**Q23: What is synchronization?**
A mechanism to control concurrent access to shared resources using the synchronized keyword (method or block). Ensures only one thread executes the critical section.

**Q24: Difference between wait() and sleep()?**
wait(): releases the lock (monitor), must be in a synchronized block, waits for notify()/notifyAll(). sleep(): keeps the lock, pauses the thread for a duration.

**Q25: What is a deadlock?**
A situation where 2+ threads wait for each other indefinitely. Example: Thread1 holds lock A waiting for B, Thread2 holds lock B waiting for A. Prevention: lock ordering, timeout.

**Q26: Explain volatile**
Keyword guaranteeing visibility of changes between threads (no CPU cache). Does not provide atomicity for compound operations. Useful for boolean flags.

**Q27: What is the Executor Framework?**
High-level API for managing threads (java.util.concurrent). ExecutorService manages a thread pool. Avoids manual creation/destruction. Methods: execute(), submit(), shutdown().

**Q28: Difference between execute() and submit()?**
execute(): takes Runnable, void, no return. submit(): takes Runnable/Callable, returns Future to retrieve result or exception.

**Q29: What is a Callable?**
Interface like Runnable but returns a result and can throw checked exceptions. Method call() instead of run().

**Q30: What is a Future?**
Represents the result of an asynchronous operation. Methods: get() (blocking), cancel(), isDone(), isCancelled().

**Q31: Difference between CountDownLatch and CyclicBarrier?**
CountDownLatch: decremented counter, await() until 0, single use. CyclicBarrier: threads wait for each other, reusable, can execute an action when all arrive.

**Q32: What is a Semaphore?**
Controls access to a limited resource. Manages n permits. acquire() takes a permit, release() frees it. Useful for limiting simultaneous connections.

**Q33: Explain the Producer-Consumer pattern**
Producer produces data, Consumer consumes it. BlockingQueue solves the problem: put() blocks if full, take() blocks if empty. Automatic synchronization.

---

## üîß MEMORY MANAGEMENT

**Q34: Explain the JVM memory areas**
- Heap: objects, shared between threads, GC
- Stack: local variables, method calls, per thread
- Metaspace: class metadata (replaces PermGen since Java 8)
- Code Cache: JIT-compiled code

**Q35: Difference between Stack and Heap?**
Stack: LIFO, limited size, fast, method scope, primitive types and references. Heap: dynamic, slower, objects, GC needed, shared.

**Q36: What is a memory leak in Java?**
Unused objects that are still referenced, so not collected by GC. Causes: static collections, unregistered listeners, unbounded caches.

**Q37: How do you prevent memory leaks?**
Null out unnecessary references, use WeakReference for caches, close resources (try-with-resources), unregister listeners, limit static collection sizes.

**Q38: What is OutOfMemoryError?**
Error when JVM runs out of memory. Types: Heap space (too many objects), Metaspace (too many classes), GC overhead (GC takes >98% of time).

---

## üé® JAVA 8+ FEATURES

**Q39: What is a functional interface?**
Interface with a single abstract method. Annotated with @FunctionalInterface (optional). Can have default/static methods. Usable with lambdas. Examples: Runnable, Callable, Comparator.

**Q40: What is a lambda expression?**
A concise anonymous function: (params) -> expression. Replaces anonymous classes for functional interfaces. Example: (a, b) -> a + b

**Q41: What is a method reference?**
Shorthand for a lambda calling an existing method. Syntax: Class::method. Types: static (Math::max), instance (String::length), constructor (ArrayList::new).

**Q42: Explain the Stream API**
Functional pipeline for processing collections. Intermediate operations (lazy): filter, map, sorted. Terminal operations (eager): collect, forEach, reduce. Immutable, does not modify source.

**Q43: Difference between map() and flatMap()?**
map(): transforms element to element (1-1), Stream<T> ‚Üí Stream<R>. flatMap(): transforms element to Stream (1-n), flattens, Stream<T> ‚Üí Stream<Stream<R>> ‚Üí Stream<R>.

**Q44: Difference between filter() and findFirst()?**
filter(): intermediate operation, returns filtered Stream. findFirst(): terminal, returns Optional of first element.

**Q45: What is Optional?**
A container that may or may not contain a value. Avoids NullPointerException. Methods: isPresent(), orElse(), orElseThrow(), map(), ifPresent().

**Q46: When should you use Optional?**
For return values that may be absent, never for parameters or fields. Alternative to returning null. Forces explicit handling of absence.

**Q47: What is a default method in interfaces?**
A method with an implementation inside an interface (since Java 8). Allows adding methods without breaking compatibility. Classes can override it.

**Q48: What is a static method in interfaces?**
A static method inside an interface. Useful for utility methods related to the interface. Not inherited or overridable.

---

## üìù STRINGS

**Q49: Is String mutable or immutable?**
Immutable. Each modification creates a new object. Reasons: security, thread-safety, optimization (String pool), constant hashcode.

**Q50: Difference between String, StringBuilder, and StringBuffer?**
String: immutable. StringBuilder: mutable, not thread-safe, fast. StringBuffer: mutable, thread-safe (synchronized), slower.

**Q51: What is the String pool?**
A special area of the Heap for storing String literals. Reuses identical objects. intern() forces addition to the pool. Saves memory.

**Q52: Difference between == and equals() for String?**
== compares references (memory addresses). equals() compares content (characters). Always use equals() to compare values.

**Q53: How do regular expressions work in Java?**
Pattern.compile(regex) compiles the expression. Matcher tests the String. Methods: matches() (full match), find() (partial), replaceAll(). Classes in java.util.regex.

---

## üîê EXCEPTION HANDLING

**Q54: Difference between Exception and Error?**
Exception: recoverable conditions, must be handled (checked/unchecked). Error: serious JVM problems, non-recoverable (OutOfMemoryError, StackOverflowError).

**Q55: Difference between checked and unchecked exceptions?**
Checked: verified at compile time, extends Exception, must be declared/handled (IOException, SQLException). Unchecked: runtime, extends RuntimeException, optional (NullPointerException, IllegalArgumentException).

**Q56: Explain try-catch-finally**
try: risky code. catch: handles exception. finally: always executed (except System.exit()), even after return/exception. Useful for cleanup.

**Q57: What is try-with-resources?**
Automatically closes resources implementing AutoCloseable. Syntax: try (Resource r = ...) {...}. Since Java 7. Safer than finally.

**Q58: Can you have multiple catch blocks?**
Yes, from most specific to most general. Since Java 7, multi-catch: catch (IOException | SQLException e).

**Q59: When should you create a custom exception?**
For specific business logic, better expressiveness. Extends Exception (checked) or RuntimeException (unchecked). Add standard constructors.

---

## üèóÔ∏è INNER CLASSES

**Q60: What types of inner classes exist?**
- Inner class (non-static): accesses outer members
- Static nested class: no access to outer instance
- Local class: inside a method
- Anonymous class: no name, single use

**Q61: When should you use a static nested class?**
When logically tied to the outer class but independent of its instance. Saves memory (no implicit reference). Example: Builder pattern.

**Q62: What is an anonymous class?**
A class without a name, declared and instantiated in one expression. Single use, often for interfaces/abstract classes. Replaced by lambdas (functional interfaces).

---

## üîÑ SERIALIZATION

**Q63: What is serialization?**
Converting an object into a byte stream for storage/transmission. Class must implement Serializable. Uses ObjectOutputStream/ObjectInputStream.

**Q64: What is serialVersionUID?**
A unique version identifier for a serializable class. If it changes, InvalidClassException is thrown during deserialization. Always declare it explicitly.

**Q65: How do you exclude a field from serialization?**
Use the transient keyword. The field will be null/0/false after deserialization. Useful for sensitive or non-serializable data.

**Q66: Difference between Serializable and Externalizable?**
Serializable: automatic, simple, limited control. Externalizable: manual, writeExternal()/readExternal() methods, full control, better performance.

---

## üéØ JAVA 9-17 FEATURES

**Q67: What is the module system (Java 9)?**
JPMS (Java Platform Module System). module-info.java file defines dependencies. exports/requires control visibility. Strong encapsulation, smaller JRE.

**Q68: What is var (Java 10)?**
Local type inference. var list = new ArrayList<String>(); Only for local variables, not fields/parameters/return types. Type determined at compile time.

**Q69: What are Records (Java 14-16)?**
Compact immutable classes for data. record Point(int x, int y) {} generates constructor, getters, equals(), hashCode(), toString(). Final, extends Record.

**Q70: What are Sealed Classes (Java 17)?**
Controls which classes can inherit. sealed class Shape permits Circle, Square {...}. Subclasses must be: final, sealed, or non-sealed. Closed hierarchy.

**Q71: What is Pattern Matching for instanceof (Java 16)?**
Simplifies cast after instanceof. Before: if (obj instanceof String) { String s = (String) obj; }. After: if (obj instanceof String s) { // use s }

**Q72: What are Text Blocks (Java 15)?**
Multi-line Strings with """. Preserves formatting, auto-escapes quotes. Useful for JSON, SQL, HTML.

**Q73: What are Switch Expressions (Java 14)?**
Switch that returns a value. Arrow syntax (->), no break needed, yield for blocks. var result = switch(day) { case MON -> "Bad"; case FRI -> "Good"; };

**Q74: Difference between switch statement and switch expression?**
Statement: executes code, break needed, no return. Expression: returns a value, no break, exhaustive (must cover all cases).

---

## üîç REFLECTION & ANNOTATIONS

**Q75: What is Reflection?**
Inspecting/modifying classes, methods, and fields at runtime. Class.forName(), getMethod(), getField(). Useful for frameworks, but costly in performance and security.

**Q76: What is an annotation?**
Metadata added to code. Prefixed with @. Retention: SOURCE, CLASS, RUNTIME. Targets: TYPE, METHOD, FIELD, etc. Examples: @Override, @Deprecated, @FunctionalInterface.

**Q77: How do you create a custom annotation?**
@interface MyAnnotation { String value(); int count() default 1; }. Define @Retention and @Target. Read via Reflection.

---

## üìä ENUMS

**Q78: What is an Enum?**
A special type of class for constants. Thread-safe singleton. Can have fields, methods, private constructors. Implicitly final and extends Enum.

**Q79: Can you inherit from an Enum?**
No, all enums implicitly extend java.lang.Enum (final). But they can implement interfaces.

**Q80: Useful Enum methods?**
values(): returns array. valueOf(String): gets enum by name. ordinal(): position. name(): constant name.

---

## üõ†Ô∏è GENERICS

**Q81: Why use Generics?**
Type-safety at compile time, no casting, reusable code. Prevents ClassCastException. Example: List<String> instead of List.

**Q82: What is type erasure?**
Removal of generic type information at compile time for bytecode compatibility. List<String> becomes List at runtime. Limitations: instanceof, new T[], T.class not possible.

**Q83: Difference between <? extends T> and <? super T>?**
Extends (upper bound): read-only, covariance. Super (lower bound): write, contravariance. PECS: Producer Extends, Consumer Super.

**Q84: What is a parameterized type?**
Class/interface/method with type parameters. Example: class Box<T> { T value; }. T is the type parameter, replaced at usage.

**Q85: Can you create a generic array?**
Not directly due to type erasure. T[] arr = new T[10] is forbidden. Solution: (T[]) new Object[10] with a warning, or ArrayList<T>.

---

## ‚ö° PERFORMANCE & BEST PRACTICES

**Q86: What is the DRY principle?**
Don't Repeat Yourself. Avoid code duplication. Refactor into methods/classes. Improves maintainability.

**Q87: What is SOLID?**
5 OOP principles: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.

**Q88: Explain the "Fail Fast" principle**
Detect errors as early as possible. Validate parameters, throw exceptions immediately. Example: Objects.requireNonNull().

**Q89: What is immutability?**
An object whose state does not change after creation. Advantages: thread-safe, stable hashcode, cache-friendly. Examples: String, Integer.

**Q90: How do you create an immutable class?**
Final class, private final fields, no setters, deep copy in constructor/getters for mutable objects, no state-modifying methods.

**Q91: What is the Singleton pattern?**
A single instance of a class. Implementation: private constructor, static instance, getInstance() method. Thread-safe with enum or synchronized.

**Q92: Difference between == and equals() for objects?**
== compares references. equals() compares content (must be overridden). If equals() is overridden, also override hashCode() (contract).

**Q93: Contract between equals() and hashCode()?**
If a.equals(b), then a.hashCode() == b.hashCode(). The reverse is not required (collisions ok). Important for HashMap, HashSet.

**Q94: What is the Builder pattern?**
Creates complex objects step by step. Avoids constructors with too many parameters. Immutable with final after build(). Readable.

**Q95: What is the Factory pattern?**
Creates objects without exposing creation logic. Common interface, different implementations. Example: Collections.unmodifiableList().

---

## üåê I/O & NIO

**Q96: Difference between InputStream and Reader?**
InputStream: byte stream (binary). Reader: character stream (text, encoding). Example: FileInputStream vs FileReader.

**Q97: What is NIO?**
New I/O (java.nio). Non-blocking, buffer/channel-oriented. More performant for concurrent I/O. Classes: Path, Files, ByteBuffer, Channel.

**Q98: Difference between Path and File?**
File: legacy, limited methods. Path: modern (Java 7+), interface, more methods, better exceptions, relativize(), normalize().

**Q99: How do you read a file in modern Java?**
Files.readAllLines(path), Files.lines(path) (Stream), Files.readString(path) (Java 11+). Try-with-resources for streams.

**Q100: What is a ByteBuffer?**
Buffer for binary data in NIO. Position, limit, capacity. Methods: flip(), clear(), compact(). Direct vs heap buffers.

---

## üî¢ MATH & UTILITIES

**Q101: Difference between int and Integer?**
int: primitive type, 32 bits, default value 0. Integer: wrapper class, object, can be null, utility methods, autoboxing/unboxing.

**Q102: What is autoboxing?**
Automatic conversion primitive ‚Üî wrapper. int ‚Üí Integer (boxing), Integer ‚Üí int (unboxing). Watch out for performance (object creation).

**Q103: Useful methods of the Math class?**
max/min, abs, pow, sqrt, random, round, floor, ceil, sin/cos/tan. All static.

**Q104: How do you generate random numbers?**
Math.random() (0.0‚Äì1.0), Random class (nextInt, nextDouble), ThreadLocalRandom (concurrent), SecureRandom (cryptographic).

**Q105: Difference between Random and ThreadLocalRandom?**
Random: synchronized, contention in multithreading. ThreadLocalRandom: one instance per thread, better concurrent performance.

---

## üìÖ DATE & TIME API (Java 8+)

**Q106: Why was a new Date/Time API introduced in Java 8?**
java.util.Date/Calendar: mutable, not thread-safe, confusing API, buggy. New API: immutable, thread-safe, clear, based on Joda-Time.

**Q107: Main classes of the Date/Time API?**
LocalDate (date), LocalTime (time), LocalDateTime (date+time), ZonedDateTime (with timezone), Instant (UTC timestamp), Period (date-based duration), Duration (time-based duration).

**Q108: Difference between Period and Duration?**
Period: date-based duration (years, months, days). Duration: time-based duration (hours, minutes, seconds, nanos). Period for dates, Duration for time.

**Q109: How do you parse/format dates?**
DateTimeFormatter: parse(String), format(LocalDate). Predefined patterns (ISO_DATE) or custom (dd-MM-yyyy). Thread-safe unlike SimpleDateFormat.

---

## üîí SECURITY

**Q110: How do you handle sensitive data?**
Do not log it, use char[] instead of String (for passwords), clear after use, encrypt at rest, HTTPS for transmission.

**Q111: What is the java.security package?**
Classes for cryptography, signatures, certificates. MessageDigest (hashing), Cipher (encryption), KeyPairGenerator, SecureRandom.

**Q112: Difference between encoding and encryption?**
Encoding: reversible transformation without a key (Base64, UTF-8). Encryption: secured with a key. Hashing: irreversible (SHA-256).

---

## üé™ ADVANCED QUESTIONS

**Q113: What is the JIT Compiler?**
Just-In-Time Compiler. Compiles bytecode into native code at runtime to optimize performance. HotSpot detects "hot" (frequently executed) code and compiles it.

**Q114: Difference between shallow copy and deep copy?**
Shallow: copies references, objects are shared. Deep: recursively copies objects, they are independent. clone() performs shallow copy by default.

**Q115: What is covariant return type?**
An overriding method can return a subtype of the parent's return type. Since Java 5. Example: Object clone() overridden as MyClass clone().

**Q116: What is the diamond problem?**
Multiple inheritance conflict when two parents have the same method. Java avoids it via single class inheritance, but interfaces can face it (resolved with default methods).

**Q117: What is the System class?**
A final utility class. Methods: currentTimeMillis(), arraycopy(), getProperty(), exit(), gc(). Access to stdin/stdout/stderr via in/out/err.

**Q118: How do you compare code performance?**
System.nanoTime() (more precise than currentTimeMillis), JMH (Java Microbenchmark Harness) for reliable benchmarks. JVM warm-up is important.

**Q119: What are assertions?**
Debug checks with assert. Disabled by default, enabled with -ea. For internal tests, not production validation. Throws AssertionError.

**Q120: Difference between composition and inheritance?**
Inheritance: "is-a" relationship, tight coupling. Composition: "has-a" relationship, loose coupling, flexible. Prefer composition (SOLID principle).

---

## üí° INTERVIEW TIPS

**Approach:**
- Answer clearly and progressively
- Give concrete examples from your experience
- Don't hesitate to draw diagrams (architecture, class diagrams)
- If you don't know, say so honestly
- Ask clarifying questions
- Show your reasoning, not just the answer

**Key points to highlight:**
- Performance and optimization
- Thread-safety and concurrency
- Design patterns
- Clean code and best practices
- Practical experience with Java 17

Good luck with your interview! üí™üöÄ
